/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
/*
 * Copyright (c) 2019 University of Erlangen-Nuernberg
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation;
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 * Author: Joerg Deutschmann <joerg.deutschmann@fau.de>
 *
 * This work has been funded by the Federal Ministry of Economics and
 * Technology of Germany in the project Transparent Multichannel IPv6
 * (FKZ 50YB1705).
 */

#include "ns3/log.h"
#include "ns3/ipv4-address.h"
#include "ns3/nstime.h"
#include "ns3/inet-socket-address.h"
#include "ns3/inet6-socket-address.h"
#include "ns3/socket.h"
#include "ns3/simulator.h"
#include "ns3/socket-factory.h"
#include <ns3/tcp-socket-factory.h>
#include "ns3/packet.h"
#include "ns3/uinteger.h"
#include "ns3/double.h"
#include "seq-ts-header.h"
#include <cstdlib>
#include <cstdio>
#include "ns3/tranGia.h"

namespace ns3 {

NS_LOG_COMPONENT_DEFINE ("TranGia");


void TranGia::ErrorCloseCallback (Ptr<Socket> socket)
{
    NS_ASSERT_MSG(false, "ErrorCloseCallback()");
}

void TranGia::InitFlowArray()
{
    for(int i = 0; i < TG_PARALLEL_FLOWS; i++)
    {
        flowArray[i].state = TGS_UNDEFINED;
        flowArray[i].sock  = 0;
        flowArray[i].pendingObject = false;
        flowArray[i].pendingBytes = 0;
    }
}

int TranGia::GetSocketIdx(Ptr<Socket> socket)
{
    // consistency checks
    if(m_mode == TGM_SEQ || m_mode == TGM_HTTP2)
    {
        NS_ASSERT(flowArray[0].sock == socket);
    }

    for(int i = 0; i < TG_PARALLEL_FLOWS; i++)
    {
        if(socket == flowArray[i].sock) {
            return i;
        }
    }

    NS_ASSERT_MSG(false, "Socket not found");
    return 0;
}





TranGiaClient::TranGiaClient ()
{
    NS_ASSERT_MSG(false, "Default constructor not implemented");
}

TranGiaClient::TranGiaClient (tranGiaMode_e tranGiaMode, Ipv4Address destIp, uint16_t destPort, std::string logFilename)
{
  NS_LOG_FUNCTION (this);

  NS_ASSERT(TG_PARALLEL_FLOWS >= 1);

  InitFlowArray();
  m_nrTotalObjects = 0;
  m_nrRequestedObjects = 0;
  m_nrReceivedObjects = 0;
  NS_ASSERT(objectSizes.empty());

  m_mode = tranGiaMode;

  //m_sizeMainObjectsWeibull
  double scale = 28242.8;
  double shape = 0.814944;
  double bound = 8000000;
  m_sizeMainObjectsWeibull = CreateObject<WeibullRandomVariable> ();
  m_sizeMainObjectsWeibull->SetAttribute("Scale", DoubleValue(scale));
  m_sizeMainObjectsWeibull->SetAttribute("Shape", DoubleValue(shape));
  m_sizeMainObjectsWeibull->SetAttribute("Bound", DoubleValue(bound));

  //m_nrMainObjectsLogNormal
  double mu = 0.473844;
  double sigma = 0.688471;
  m_nrMainObjectsLogNormal = CreateObject<LogNormalRandomVariable> ();
  m_nrMainObjectsLogNormal->SetAttribute ("Mu", DoubleValue (mu));
  m_nrMainObjectsLogNormal->SetAttribute ("Sigma", DoubleValue (sigma));

  //m_sizeEmbObjectsLognormal
  mu = 9.17979;
  sigma = 1.24646;
  m_sizeEmbObjectsLognormal = CreateObject<LogNormalRandomVariable> ();
  m_sizeEmbObjectsLognormal->SetAttribute ("Mu", DoubleValue (mu));
  m_sizeEmbObjectsLognormal->SetAttribute ("Sigma", DoubleValue (sigma));

  //m_nrEmbObjectsExp
  double mean = 31.9291;
  bound = 1920.0;
  m_nrEmbObjectsExp = CreateObject<ExponentialRandomVariable> ();
  m_nrEmbObjectsExp->SetAttribute("Mean", DoubleValue(mean));
  m_nrEmbObjectsExp->SetAttribute("Bound", DoubleValue(bound));

  m_destIp = destIp;
  m_destPort = destPort;

  m_ofStat.open(logFilename);
  m_ofStat << "startTime,nrMainObjects,mainObjectSizes,mainObjectsTotalSize,nrEmbObjects,embObjectSizes,embObjectsTotalSize,finishTime" << std::endl;
}


TranGiaClient::~TranGiaClient ()
{
  NS_LOG_FUNCTION (this);
}


void
TranGiaClient::DoDispose (void)
{
  NS_LOG_FUNCTION (this);
  m_ofStat.close();
  Application::DoDispose ();
}


// the number of objects and their sizes are generated by the client and sent
// to the server with the main object request
void
TranGiaClient::StartApplication (void)
{
  NS_LOG_FUNCTION (this);

  InitFlowArray();
  m_nrTotalObjects = 0;
  m_nrRequestedObjects = 0;
  m_nrReceivedObjects = 0;
  NS_ASSERT(objectSizes.empty());

  //prepare sockets
  for(int i = 0; i < TG_PARALLEL_FLOWS; i++)
  {
      flowArray[i].sock = Socket::CreateSocket (GetNode (), TcpSocketFactory::GetTypeId ());

      flowArray[i].sock->SetConnectCallback (MakeCallback (&TranGiaClient::ConnectionSucceededCallback, this),
                                             MakeNullCallback<void, Ptr<Socket> > ());
      flowArray[i].sock->SetRecvCallback (MakeCallback (&TranGiaClient::ReceivedDataCallback, this));
  }

  m_ofStat << Simulator::Now().GetNanoSeconds() << ",";

  // Main objects
  // there must be at least one main object
  // the do{}while() loop is also required to obtain mean and std dev as specified in the Tran-Gia paper
  uint32_t nrMainObjects;
  do
  {
      nrMainObjects = m_nrMainObjectsLogNormal->GetInteger ();
  } while (nrMainObjects < 1);
  m_ofStat << nrMainObjects << ",";

  uint32_t totalSize = 0;
  for(uint32_t i = 0; i < nrMainObjects; i++)
  {
      uint32_t value = m_sizeMainObjectsWeibull->GetInteger();
      objectSizes.push_back(value);
      m_ofStat << value << ":"; // mainObjectSizes
      totalSize += value;
  }
  m_ofStat << "," << totalSize << ","; //mainObjectsTotalSize

  // Embedded objects
  uint32_t nrEmbObjects = m_nrEmbObjectsExp->GetInteger ();
  m_ofStat << nrEmbObjects << ",";

  totalSize = 0;
  for(uint32_t i = 0; i < nrEmbObjects; i++)
  {
      uint32_t value = m_sizeEmbObjectsLognormal->GetInteger();
      objectSizes.push_back(value);
      m_ofStat << value << ":"; //embObjectsSizes
      totalSize += value;
  }
  m_ofStat << "," << totalSize << ","; //embObjectsTotalSize

  // The Tran-Gia paper does not give details on the number of main objects,
  // i.e. does every main object trigger another set of emb objects?
  // We assume that further main objects can be simple be treated as additional
  // objects.
  m_nrTotalObjects = nrMainObjects + nrEmbObjects;
  NS_LOG_INFO("Requesting " << m_nrTotalObjects << " objects");

  //initiate main object connection
  //very fast due to split TCP
  InetSocketAddress inetSocket = InetSocketAddress (m_destIp, m_destPort);
  flowArray[0].sock->Connect(inetSocket);
  flowArray[0].state = TGS_TCPCONNECT;
}


void
TranGiaClient::StopApplication ()
{
  NS_LOG_FUNCTION (this);

  NS_ASSERT(objectSizes.empty());
}


void
TranGiaClient::NormalCloseCallback (Ptr<Socket> socket)
{
    NS_ASSERT_MSG(false, "TranGiaClient::NormalCloseCallback() should not happen");
}


void
TranGiaClient::ConnectionSucceededCallback (Ptr<Socket> socket)
{
  NS_LOG_FUNCTION (this << socket);

  tcpHeader_t tcpHdr;

  int idx = GetSocketIdx(socket);

  NS_ASSERT(flowArray[idx].state == TGS_TCPCONNECT);

  tcpHdr.hdr.type = TGS_CONNECT1;
  tcpHdr.hdr.payloadSize = TG_HDRTCP_DUMMY;

  int status = flowArray[idx].sock->Send((uint8_t*)&tcpHdr, sizeof(tcpHdr), 0);
  NS_ASSERT(status == sizeof(tcpHdr));
  flowArray[idx].state = TGS_CONNECT1;
}


void
TranGiaClient::ReceivedDataCallback (Ptr<Socket> socket)
{
    NS_LOG_FUNCTION (this << socket);

    int status = 0;
    commonHeader_t hdr;
    uint8_t buffer[TG_MAXBUFSIZE] = {0};

    int idx = GetSocketIdx(socket);

    //receive commonHeader (similar to ReceivedDataCallback in TranGiaServer)
    if(flowArray[idx].pendingObject == false
            && socket->GetRxAvailable() < sizeof(hdr))
    {
        //wait for the next ReceivedDataCallback()
        NS_LOG_INFO("New object, but less than a tranGiaPkt header (only " << socket->GetRxAvailable() << " bytes are available)");
        return;
    }

    if(flowArray[idx].pendingObject == false)
    {
        status = socket->Recv((uint8_t*)&hdr, sizeof(hdr), 0);
        NS_ASSERT(status == sizeof(hdr));

        NS_LOG_INFO("flowArray[" << idx << "] Received an header, object type: " << hdr.type << ", size: " << hdr.payloadSize);
        flowArray[idx].pendingBytes = hdr.payloadSize;  // the size of the object which will be requested
        flowArray[idx].pendingObject = true;
    }

    // Remember: ReceivedDataCallback() might be called multiple times (e.g. if there is a large object)
    // and therefore the received hdr must not be used later on
    memset(&hdr, 0, sizeof(hdr));


    //receive data
    do
    {
        status = socket->Recv(buffer,
                              flowArray[idx].pendingBytes < TG_MAXBUFSIZE ? flowArray[idx].pendingBytes : TG_MAXBUFSIZE,
                              0);
        flowArray[idx].pendingBytes -= status;

        if(status != 0)
        {
            NS_LOG_INFO("Received " << status << " bytes, and " << flowArray[idx].pendingBytes << " bytes are remaining");
        }
    } while (status != 0);

    if(flowArray[idx].pendingBytes > 0)
    {
        NS_LOG_INFO("There are " << flowArray[idx].pendingBytes << " pending bytes, waiting for the next ReceivedDataCallback()");
        return;
    }
    NS_ASSERT(socket->GetRxAvailable() == 0);


    //finish condition
    if(m_nrRequestedObjects == m_nrTotalObjects)
    {
        status = flowArray[idx].sock->Close();
        NS_ASSERT(status == 0);

        if(    flowArray[idx].state == TGS_MAINOBJECT
            || flowArray[idx].state == TGS_EMBOBJECT)
        {
            m_nrReceivedObjects++;

            if(m_nrReceivedObjects == m_nrTotalObjects)
            {
                // website finished;
                // - in case of parallel connections, other flows might still be in
                //   connection setup, which causes problems if websites are loaded
                //   without a break (e.g., readingTime = 0)
                // - we expect that all flows finish their object gracefully to not confuse our PEP :-/
                NS_LOG_INFO("Finished a web site consisting of a total of " << m_nrTotalObjects << " objects");
                m_ofStat << Simulator::Now().GetNanoSeconds() << std::endl;

                for(int j = 0; j < TG_PARALLEL_FLOWS; j++)
                {
                    NS_LOG_INFO("flowArray[" << j << "].state is " << flowArray[j].state);
                }

                StopApplication(); // Reading time not implemented yet
            }
        }

        NS_LOG_INFO("Finished requesting all " << m_nrTotalObjects << " objects, received " << m_nrReceivedObjects << " so far");

        return;
    }



    //////////////////
    // check states //
    //////////////////
    if(flowArray[idx].state == TGS_CONNECT1)
    {
        NS_LOG_INFO("Received CONNECT1 packet, going to state CONNECT2");

        tlsHeader_t tlsHdr;
        tlsHdr.hdr.type = TGS_CONNECT2;
        tlsHdr.hdr.payloadSize = TG_HDRTLS_DUMMY;
        memcpy(buffer, &tlsHdr, sizeof(tlsHdr));
        status = flowArray[idx].sock->Send(buffer, sizeof(tlsHdr), 0);
        NS_ASSERT_MSG(status == sizeof(tlsHdr), "status is " << status << ", Errno is " << flowArray[idx].sock->GetErrno());

        flowArray[idx].state = TGS_CONNECT2;

        flowArray[idx].pendingObject = false;
        return;
    }

    // additional flow connected, request emb object
    if(flowArray[idx].state == TGS_CONNECT2 && idx >= 1)
    {
        NS_ASSERT(m_mode == TGM_PARALLEL);
        NS_LOG_INFO("Parallel mode (flow idx " << idx << "), Received CONNECT2 packet, going to request emb. objects");

        httpHeader_t httpHdr;
        httpHdr.hdr.type = TGS_EMBOBJECT;
        httpHdr.hdr.payloadSize = objectSizes.front();
        objectSizes.pop_front();
        memcpy(buffer, &httpHdr, sizeof(httpHdr));
        status = flowArray[idx].sock->Send(buffer, sizeof(httpHdr), 0);
        NS_ASSERT(status == sizeof(httpHdr));

        flowArray[idx].state = TGS_EMBOBJECT;
        m_nrRequestedObjects++;

        flowArray[idx].pendingObject = false;
        return;
    }

    // main flow connected, request main object
    if(flowArray[idx].state == TGS_CONNECT2)
    {
        NS_ASSERT(idx == 0);
        NS_LOG_INFO("Main flow, Received CONNECT2 packet, going to request main object (in total "
                <<  m_nrTotalObjects << " objects)");

        // request main object
        httpHeader_t httpHdr;
        httpHdr.hdr.type = TGS_MAINOBJECT;
        httpHdr.hdr.payloadSize = objectSizes.front();
        objectSizes.pop_front();
        memcpy(buffer, &httpHdr, sizeof(httpHdr));
        status = flowArray[idx].sock->Send(buffer, sizeof(httpHdr), 0);
        NS_ASSERT(status == sizeof(httpHdr));

        flowArray[idx].state = TGS_MAINOBJECT;
        m_nrRequestedObjects = 1;

        flowArray[idx].pendingObject = false;
        return;
    }

    // main object received, request emb object
    if(flowArray[idx].state == TGS_MAINOBJECT)
    {
        m_nrReceivedObjects = 1;
        NS_ASSERT(idx == 0);
        NS_LOG_INFO("Main flow, Received main object (total of " << m_nrTotalObjects << " objects)");

        // in case of HTTP/1.1, we need to set up more connections
        if(m_mode == TGM_PARALLEL)
        {
            //flow[0] already established; Example: 6 parallel flows -> flow[1..5]
            uint8_t parallelFlows = (m_nrTotalObjects-1 >= TG_PARALLEL_FLOWS) ? TG_PARALLEL_FLOWS-1 : m_nrTotalObjects-1;
            NS_LOG_INFO("Parallel mode, creating further flows (idx 1.." << (int)parallelFlows << ")");

            for(int i = 1; i <= parallelFlows; i++)
            {
                InetSocketAddress inetSocket = InetSocketAddress (m_destIp, m_destPort);
                flowArray[i].sock->Connect(inetSocket);
                flowArray[i].state = TGS_TCPCONNECT;
            }
        }

        httpHeader_t httpHdr;
        if(m_mode == TGM_HTTP2)
        {
            // with http/2, there is one main object and one big emb. object
            m_nrTotalObjects = 2;

            httpHdr.hdr.payloadSize = 0;
            while(!objectSizes.empty())
            {
                httpHdr.hdr.payloadSize += objectSizes.front();
                objectSizes.pop_front();
            }
        }
        else
        {
            httpHdr.hdr.payloadSize = objectSizes.front();
            objectSizes.pop_front();
        }

        NS_LOG_INFO("Main flow, Requesting embedded object");

        httpHdr.hdr.type = TGS_EMBOBJECT;
        //hdr.payloadSize already set
        memcpy(buffer, &httpHdr, sizeof(httpHdr));
        flowArray[idx].sock->Send(buffer, sizeof(httpHdr), 0);
        flowArray[idx].state = TGS_EMBOBJECT;
        m_nrRequestedObjects++;

        flowArray[idx].pendingObject = false;
        return;
    }

    // emb. object received, request further emb objects
    if(flowArray[idx].state == TGS_EMBOBJECT)
    {
        m_nrReceivedObjects++;
        NS_LOG_INFO("Main flow, Received emb. object (" <<  m_nrReceivedObjects << " of " << m_nrTotalObjects << " objects received)");
        NS_ASSERT(m_nrRequestedObjects < m_nrTotalObjects);

        // request next emb object
        httpHeader_t httpHdr;
        httpHdr.hdr.type = TGS_EMBOBJECT;
        httpHdr.hdr.payloadSize = objectSizes.front();
        objectSizes.pop_front();
        memcpy(buffer, &httpHdr, sizeof(httpHdr));
        flowArray[idx].sock->Send(buffer, sizeof(httpHdr), 0);
        flowArray[idx].state = TGS_EMBOBJECT;
        m_nrRequestedObjects++;

        NS_LOG_INFO("Flow idx " << idx << ", nrRequestedObjects: " << m_nrRequestedObjects
                                       << ", nrReceivedObjects: " << m_nrReceivedObjects
                                       << ", nrTotalObjects: " << m_nrTotalObjects);

        flowArray[idx].pendingObject = false;
        return;
    }

    NS_ASSERT_MSG(false, "Invalid state");
}





TranGiaServer::TranGiaServer ()
{
    NS_ASSERT_MSG(false, "Default constructor not implemented");
}

TranGiaServer::TranGiaServer (tranGiaMode_e tranGiaMode)
{
    NS_LOG_FUNCTION (this);

    NS_ASSERT(TG_PARALLEL_FLOWS >= 1);

    InitFlowArray();

    m_mode = tranGiaMode;
}

TranGiaServer::~TranGiaServer ()
{
    NS_LOG_FUNCTION (this);
}

void
TranGiaServer::DoDispose (void)
{
    NS_LOG_FUNCTION (this);
    Application::DoDispose ();
}


void
TranGiaServer::StartApplication (void)
{
    NS_LOG_FUNCTION (this);

    InitFlowArray();

    //prepare listen socket
    m_listenSocket = Socket::CreateSocket (GetNode (), TcpSocketFactory::GetTypeId ());
    if (m_listenSocket->Bind (InetSocketAddress (Ipv4Address::GetAny (), 80)) == -1)
    {
        NS_FATAL_ERROR ("Failed to bind socket");
    }

    m_listenSocket->SetAcceptCallback(MakeNullCallback<bool, Ptr<Socket>, const Address &> (),
                                      MakeCallback (&TranGiaServer::NewConnectionCreatedCallback, this));

    int ret = m_listenSocket->Listen ();
    NS_LOG_DEBUG (this << " Listen () return value= " << ret);

    NS_ASSERT_MSG (m_listenSocket != 0, "Failed creating socket.");
}

void
TranGiaServer::StopApplication ()
{
    NS_LOG_FUNCTION (this);
    NS_ASSERT_MSG(false, "TranGiaServer::StopApplication not implemented yet");
}

void
TranGiaServer::NormalCloseCallback (Ptr<Socket> socket)
{
    NS_LOG_FUNCTION (this << socket);

    int i = GetSocketIdx(socket);
    NS_LOG_INFO("flowArray[" << i << "] finished");

    flowArray[i].sock->ShutdownRecv();
    flowArray[i].sock->ShutdownSend();
    flowArray[i].sock->SetRecvCallback (MakeNullCallback<void, Ptr<Socket> > ());
    flowArray[i].sock->SetSendCallback (MakeNullCallback<void, Ptr<Socket>, uint32_t > ());
    flowArray[i].sock = 0;
}

void
TranGiaServer::NewConnectionCreatedCallback (Ptr<Socket> socket,
        const Address &address)
{
    NS_LOG_FUNCTION (this << socket << address);

    // the accept socket is different from the initial socket which is no longer needed
    Address sockLocal, sockRemote;
    socket->GetSockName(sockLocal);
    socket->GetPeerName(sockRemote);
    NS_LOG_INFO("sockLocal  ip " << InetSocketAddress::ConvertFrom (sockLocal).GetIpv4 ()  << "   port " << InetSocketAddress::ConvertFrom (sockLocal).GetPort ());
    NS_LOG_INFO("sockRemote ip " << InetSocketAddress::ConvertFrom (sockRemote).GetIpv4 () << "   port " << InetSocketAddress::ConvertFrom (sockRemote).GetPort ());

    int i = 0;
    for(i = 0; i < TG_PARALLEL_FLOWS; i++)
    {
        if(flowArray[i].sock == 0)
        {
            NS_LOG_INFO("New connection created, using flowArray[" << i << "]");
            flowArray[i].sock = socket;
            flowArray[i].state = TGS_CONNECT1;
            flowArray[i].pendingObject = false;
            break;
        }
    }
    NS_ASSERT(i < TG_PARALLEL_FLOWS);

    socket->SetRecvCallback (MakeCallback (&TranGiaServer::ReceivedDataCallback, this));
    socket->SetSendCallback (MakeCallback (&TranGiaServer::SendCallback, this));
    socket->SetCloseCallbacks (MakeCallback (&TranGiaServer::NormalCloseCallback, this),
                               MakeCallback (&TranGia::ErrorCloseCallback, this));

    //data may already have been received
    ReceivedDataCallback (socket);
}


void
TranGiaServer::ReceivedDataCallback (Ptr<Socket> socket)
{
    NS_LOG_FUNCTION (this << socket);

    int sendSize = 0;
    int status = 0;
    commonHeader_t hdr;
    uint8_t buffer[2*TG_MAXBUFSIZE] = {0};

    int idx = GetSocketIdx(socket);

    //receive commonHeader (similar to ReceivedDataCallback in TranGiaClient)
    if(    flowArray[idx].pendingObject == false
            && socket->GetRxAvailable() < sizeof(hdr))
    {
        //wait for the next ReceivedDataCallback()
        NS_LOG_INFO("New object, but less than a tranGiaPkt header (only " << socket->GetRxAvailable() << " bytes are available)");
        return;
    }

    if(flowArray[idx].pendingObject == false)
    {
        status = socket->Recv((uint8_t*)&hdr, sizeof(hdr), 0);
        NS_ASSERT(status == sizeof(hdr));

        NS_LOG_INFO("Received an header, object type: " << hdr.type << ", size: " << hdr.payloadSize);
        flowArray[idx].pendingBytes = hdr.payloadSize; // the size of the object which has to be send
        flowArray[idx].pendingObject = true;

        // instead of simply copying from hdr.type to state, we could add some checks/assertions
        flowArray[idx].state = (tranGiaState_e)hdr.type;
    }

    // Remember: ReceivedDataCallback() might be called multiple times (e.g. if there is a large object)
    // and therefore the received hdr must not be used later on
    memset(&hdr, 0, sizeof(hdr));


    //////////////////
    // check states //
    //////////////////
    if(flowArray[idx].state == TGS_CONNECT1)
    {
        tcpHeader_t tcpHdr;
        if(socket->GetRxAvailable() < TG_HDRTCP_DUMMY)
        {
            return;
        }
        status = socket->Recv(buffer, TG_HDRTCP_DUMMY, 0);
        NS_ASSERT(status == TG_HDRTCP_DUMMY);

        NS_LOG_INFO("Replaying CONNECT1 packet");

        tcpHdr.hdr.type = TGS_CONNECT1;
        tcpHdr.hdr.payloadSize = TG_HDRTCP_DUMMY;
        memcpy(buffer, &tcpHdr, sizeof(tcpHdr));
        status = flowArray[idx].sock->Send(buffer, sizeof(tcpHdr), 0);
        NS_ASSERT(status == sizeof(tcpHdr));

        flowArray[idx].pendingBytes = 0;
        flowArray[idx].pendingObject = false;
        return;
    }

    if(flowArray[idx].state == TGS_CONNECT2)
    {
        tlsHeader_t tlsHdr;
        if(socket->GetRxAvailable() < TG_HDRTLS_DUMMY)
        {
            return;
        }
        status = socket->Recv(buffer, TG_HDRTLS_DUMMY, 0);
        NS_ASSERT(status == TG_HDRTLS_DUMMY);

        NS_LOG_INFO("Replaying CONNECT2 packet");

        tlsHdr.hdr.type = TGS_CONNECT2;
        tlsHdr.hdr.payloadSize = TG_HDRTLS_DUMMY;
        memcpy(buffer, &tlsHdr, sizeof(tlsHdr));
        status = flowArray[idx].sock->Send(buffer, sizeof(tlsHdr), 0);
        NS_ASSERT(status == sizeof(tlsHdr));

        flowArray[idx].pendingBytes = 0;
        flowArray[idx].pendingObject = false;
        return;
    }

    // http (main or emb) object
    NS_ASSERT(flowArray[idx].state == TGS_MAINOBJECT || flowArray[idx].state == TGS_EMBOBJECT);
    httpHeader_t httpHdr;
    if(socket->GetRxAvailable() < TG_HDRHTTP_DUMMY)
    {
        return;
    }
    status = socket->Recv(buffer, TG_HDRHTTP_DUMMY, 0);
    NS_ASSERT(status == TG_HDRHTTP_DUMMY);

    if(flowArray[idx].state == TGS_MAINOBJECT)
    {
        NS_LOG_INFO("Received MAINOBJECT request, sending response");
        httpHdr.hdr.type = TGS_MAINOBJECT;
    }
    else if(flowArray[idx].state == TGS_EMBOBJECT)
    {
        NS_LOG_INFO("Received EMBOBJECT request, sending response");
        httpHdr.hdr.type = TGS_EMBOBJECT;
    }

    httpHdr.hdr.payloadSize = TG_HDRHTTP_DUMMY + flowArray[idx].pendingBytes;
    sendSize = (flowArray[idx].pendingBytes > TG_MAXBUFSIZE) ? TG_MAXBUFSIZE : flowArray[idx].pendingBytes;
    memcpy(buffer, &httpHdr, sizeof(httpHdr));
    status = flowArray[idx].sock->Send(buffer, sizeof(httpHdr)+sendSize, 0);
    NS_ASSERT(status == (int)sizeof(httpHdr)+sendSize);

    NS_LOG_INFO("Response (Total " << flowArray[idx].pendingBytes <<", sent "
            << sendSize << ", pendingBytes " << flowArray[idx].pendingBytes);

    flowArray[idx].pendingBytes -= sendSize;
    flowArray[idx].pendingObject = false; //actually, multiple SendCallback() might be fired until object is completely transmitted

}



void
TranGiaServer::SendCallback (Ptr<Socket> socket, uint32_t availableBufferSize)
{
    NS_LOG_FUNCTION (this << socket << availableBufferSize);
    NS_ASSERT(socket->GetTxAvailable() == availableBufferSize);

    uint8_t buffer[2*TG_MAXBUFSIZE] = {0};

    int idx = GetSocketIdx(socket);

    if(flowArray[idx].pendingBytes == 0)
    {
        NS_LOG_INFO("flowArray[" << idx << "] has no more pending bytes");
        return;
    }

    uint32_t txAvailable = (availableBufferSize > TG_MAXBUFSIZE) ? TG_MAXBUFSIZE : availableBufferSize;
    int sendSize         = (flowArray[idx].pendingBytes > txAvailable) ? txAvailable : flowArray[idx].pendingBytes;

    int status = flowArray[idx].sock->Send(buffer, sendSize, 0);
    NS_ASSERT(status == sendSize);

    flowArray[idx].pendingBytes -= sendSize;

    NS_LOG_INFO("Continued response (sent " << sendSize << ", pendingBytes " << flowArray[idx].pendingBytes);
}


} // Namespace ns3
